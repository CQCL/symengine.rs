/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type std_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
pub const std__Rb_tree_color__S_red: std__Rb_tree_color = 0;
pub const std__Rb_tree_color__S_black: std__Rb_tree_color = 1;
pub type std__Rb_tree_color = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_node_base {
    pub _M_color: std__Rb_tree_color,
    pub _M_parent: std__Rb_tree_node_base__Base_ptr,
    pub _M_left: std__Rb_tree_node_base__Base_ptr,
    pub _M_right: std__Rb_tree_node_base__Base_ptr,
}
pub type std__Rb_tree_node_base__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree_node_base__Const_Base_ptr = *const std__Rb_tree_node_base;
#[test]
fn bindgen_test_layout_std__Rb_tree_node_base() {
    assert_eq!(
        ::std::mem::size_of::<std__Rb_tree_node_base>(),
        32usize,
        concat!("Size of: ", stringify!(std__Rb_tree_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Rb_tree_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Rb_tree_node_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std__Rb_tree_node_base>()))._M_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Rb_tree_node_base),
            "::",
            stringify!(_M_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std__Rb_tree_node_base>()))._M_parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Rb_tree_node_base),
            "::",
            stringify!(_M_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std__Rb_tree_node_base>()))._M_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Rb_tree_node_base),
            "::",
            stringify!(_M_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std__Rb_tree_node_base>()))._M_right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Rb_tree_node_base),
            "::",
            stringify!(_M_right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_key_compare<_Key_compare> {
    pub _M_key_compare: _Key_compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_node {
    pub _base: std__Rb_tree_node_base,
    pub _M_storage: __gnu_cxx___aligned_membuf,
}
pub type std__Rb_tree_node__Link_type = *mut std__Rb_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_iterator {
    pub _M_node: std__Rb_tree_iterator__Base_ptr,
}
pub type std__Rb_tree_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_iterator_reference<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__Rb_tree_iterator_difference_type = isize;
pub type std__Rb_tree_iterator__Self = std__Rb_tree_iterator;
pub type std__Rb_tree_iterator__Base_ptr = std__Rb_tree_node_base__Base_ptr;
pub type std__Rb_tree_iterator__Link_type = *mut std__Rb_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_const_iterator {
    pub _M_node: std__Rb_tree_const_iterator__Base_ptr,
}
pub type std__Rb_tree_const_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
pub type std__Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
pub type std__Rb_tree_const_iterator_iterator = std__Rb_tree_iterator;
pub type std__Rb_tree_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__Rb_tree_const_iterator_difference_type = isize;
pub type std__Rb_tree_const_iterator__Self = std__Rb_tree_const_iterator;
pub type std__Rb_tree_const_iterator__Base_ptr = std__Rb_tree_node_base__Const_Base_ptr;
pub type std__Rb_tree_const_iterator__Link_type = *const std__Rb_tree_node;
#[repr(C)]
#[derive(Debug)]
pub struct std__Rb_tree {
    pub _M_impl: u8,
}
pub type std__Rb_tree__Node_allocator = [u8; 0usize];
pub type std__Rb_tree__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Rb_tree__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree__Const_Base_ptr = *const std__Rb_tree_node_base;
pub type std__Rb_tree__Link_type = *mut std__Rb_tree_node;
pub type std__Rb_tree__Const_Link_type = *const std__Rb_tree_node;
#[repr(C)]
#[derive(Debug)]
pub struct std__Rb_tree__Reuse_or_alloc_node {
    pub _M_root: std__Rb_tree__Base_ptr,
    pub _M_nodes: std__Rb_tree__Base_ptr,
    pub _M_t: *mut std__Rb_tree,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree__Alloc_node {
    pub _M_t: *mut std__Rb_tree,
}
pub type std__Rb_tree_key_type<_Key> = _Key;
pub type std__Rb_tree_value_type<_Val> = _Val;
pub type std__Rb_tree_pointer<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_pointer<_Val> = *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_reference<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_reference<_Val> = *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_size_type = std_size_t;
pub type std__Rb_tree_difference_type = isize;
pub type std__Rb_tree_allocator_type<_Alloc> = _Alloc;
pub type std__Rb_tree_reverse_iterator = std_reverse_iterator<std__Rb_tree_iterator>;
pub type std__Rb_tree_const_reverse_iterator = std_reverse_iterator<std__Rb_tree_const_iterator>;
pub type std__Rb_tree___same_value_type = std_is_same;
pub type std__Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
    std__Rb_tree_key_compare<_Key_compare>;
#[repr(C)]
pub struct std_map {
    pub _M_t: std_map__Rep_type,
}
pub type std_map_key_type<_Key> = _Key;
pub type std_map_mapped_type<_Tp> = _Tp;
pub type std_map_value_type<_Key, _Tp> = std_pair<_Key, _Tp>;
pub type std_map_key_compare<_Compare> = _Compare;
pub type std_map_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map_value_compare<_Compare> {
    pub comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
pub type std_map__Pair_alloc_type = [u8; 0usize];
pub type std_map__Rep_type = std__Rb_tree;
pub type std_map__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_map_pointer = [u8; 0usize];
pub type std_map_const_pointer = [u8; 0usize];
pub type std_map_reference = [u8; 0usize];
pub type std_map_const_reference = [u8; 0usize];
pub type std_map_iterator = [u8; 0usize];
pub type std_map_const_iterator = [u8; 0usize];
pub type std_map_size_type = [u8; 0usize];
pub type std_map_difference_type = [u8; 0usize];
pub type std_map_reverse_iterator = [u8; 0usize];
pub type std_map_const_reverse_iterator = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = std_size_t;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic<_Tp> {
    pub _M_i: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_atomic_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = std_size_t;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf {
    pub _M_storage: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf__Tp2<_Tp> {
    pub _M_t: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct SymEngine_RCP<T> {
    pub ptr_: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct SymEngine_EnableRCPFromThis {
    pub refcount_: std_atomic<::std::os::raw::c_uint>,
}
pub type SymEngine_hash_t = u64;
pub type SymEngine_vec_basic = std_vector;
pub type SymEngine_map_basic_basic = std_map;
pub const SymEngine_TypeID_SYMENGINE_INTEGER: SymEngine_TypeID = 0;
pub const SymEngine_TypeID_SYMENGINE_RATIONAL: SymEngine_TypeID = 1;
pub const SymEngine_TypeID_SYMENGINE_COMPLEX: SymEngine_TypeID = 2;
pub const SymEngine_TypeID_SYMENGINE_COMPLEX_DOUBLE: SymEngine_TypeID = 3;
pub const SymEngine_TypeID_SYMENGINE_REAL_MPFR: SymEngine_TypeID = 4;
pub const SymEngine_TypeID_SYMENGINE_COMPLEX_MPC: SymEngine_TypeID = 5;
pub const SymEngine_TypeID_SYMENGINE_REAL_DOUBLE: SymEngine_TypeID = 6;
pub const SymEngine_TypeID_SYMENGINE_INFTY: SymEngine_TypeID = 7;
pub const SymEngine_TypeID_SYMENGINE_NOT_A_NUMBER: SymEngine_TypeID = 8;
pub const SymEngine_TypeID_SYMENGINE_URATPSERIESPIRANHA: SymEngine_TypeID = 9;
pub const SymEngine_TypeID_SYMENGINE_UPSERIESPIRANHA: SymEngine_TypeID = 10;
pub const SymEngine_TypeID_SYMENGINE_URATPSERIESFLINT: SymEngine_TypeID = 11;
pub const SymEngine_TypeID_SYMENGINE_NUMBER_WRAPPER: SymEngine_TypeID = 12;
pub const SymEngine_TypeID_SYMENGINE_SYMBOL: SymEngine_TypeID = 13;
pub const SymEngine_TypeID_SYMENGINE_DUMMY: SymEngine_TypeID = 14;
pub const SymEngine_TypeID_SYMENGINE_MUL: SymEngine_TypeID = 15;
pub const SymEngine_TypeID_SYMENGINE_ADD: SymEngine_TypeID = 16;
pub const SymEngine_TypeID_SYMENGINE_POW: SymEngine_TypeID = 17;
pub const SymEngine_TypeID_SYMENGINE_UINTPOLY: SymEngine_TypeID = 18;
pub const SymEngine_TypeID_SYMENGINE_MINTPOLY: SymEngine_TypeID = 19;
pub const SymEngine_TypeID_SYMENGINE_URATPOLY: SymEngine_TypeID = 20;
pub const SymEngine_TypeID_SYMENGINE_UEXPRPOLY: SymEngine_TypeID = 21;
pub const SymEngine_TypeID_SYMENGINE_MEXPRPOLY: SymEngine_TypeID = 22;
pub const SymEngine_TypeID_SYMENGINE_UINTPOLYPIRANHA: SymEngine_TypeID = 23;
pub const SymEngine_TypeID_SYMENGINE_URATPOLYPIRANHA: SymEngine_TypeID = 24;
pub const SymEngine_TypeID_SYMENGINE_UINTPOLYFLINT: SymEngine_TypeID = 25;
pub const SymEngine_TypeID_SYMENGINE_URATPOLYFLINT: SymEngine_TypeID = 26;
pub const SymEngine_TypeID_SYMENGINE_GALOISFIELD: SymEngine_TypeID = 27;
pub const SymEngine_TypeID_SYMENGINE_UNIVARIATESERIES: SymEngine_TypeID = 28;
pub const SymEngine_TypeID_SYMENGINE_LOG: SymEngine_TypeID = 29;
pub const SymEngine_TypeID_SYMENGINE_CONJUGATE: SymEngine_TypeID = 30;
pub const SymEngine_TypeID_SYMENGINE_CONSTANT: SymEngine_TypeID = 31;
pub const SymEngine_TypeID_SYMENGINE_SIGN: SymEngine_TypeID = 32;
pub const SymEngine_TypeID_SYMENGINE_FLOOR: SymEngine_TypeID = 33;
pub const SymEngine_TypeID_SYMENGINE_CEILING: SymEngine_TypeID = 34;
pub const SymEngine_TypeID_SYMENGINE_SIN: SymEngine_TypeID = 35;
pub const SymEngine_TypeID_SYMENGINE_COS: SymEngine_TypeID = 36;
pub const SymEngine_TypeID_SYMENGINE_TAN: SymEngine_TypeID = 37;
pub const SymEngine_TypeID_SYMENGINE_COT: SymEngine_TypeID = 38;
pub const SymEngine_TypeID_SYMENGINE_CSC: SymEngine_TypeID = 39;
pub const SymEngine_TypeID_SYMENGINE_SEC: SymEngine_TypeID = 40;
pub const SymEngine_TypeID_SYMENGINE_ASIN: SymEngine_TypeID = 41;
pub const SymEngine_TypeID_SYMENGINE_ACOS: SymEngine_TypeID = 42;
pub const SymEngine_TypeID_SYMENGINE_ASEC: SymEngine_TypeID = 43;
pub const SymEngine_TypeID_SYMENGINE_ACSC: SymEngine_TypeID = 44;
pub const SymEngine_TypeID_SYMENGINE_ATAN: SymEngine_TypeID = 45;
pub const SymEngine_TypeID_SYMENGINE_ACOT: SymEngine_TypeID = 46;
pub const SymEngine_TypeID_SYMENGINE_ATAN2: SymEngine_TypeID = 47;
pub const SymEngine_TypeID_SYMENGINE_SINH: SymEngine_TypeID = 48;
pub const SymEngine_TypeID_SYMENGINE_CSCH: SymEngine_TypeID = 49;
pub const SymEngine_TypeID_SYMENGINE_COSH: SymEngine_TypeID = 50;
pub const SymEngine_TypeID_SYMENGINE_SECH: SymEngine_TypeID = 51;
pub const SymEngine_TypeID_SYMENGINE_TANH: SymEngine_TypeID = 52;
pub const SymEngine_TypeID_SYMENGINE_COTH: SymEngine_TypeID = 53;
pub const SymEngine_TypeID_SYMENGINE_ASINH: SymEngine_TypeID = 54;
pub const SymEngine_TypeID_SYMENGINE_ACSCH: SymEngine_TypeID = 55;
pub const SymEngine_TypeID_SYMENGINE_ACOSH: SymEngine_TypeID = 56;
pub const SymEngine_TypeID_SYMENGINE_ATANH: SymEngine_TypeID = 57;
pub const SymEngine_TypeID_SYMENGINE_ACOTH: SymEngine_TypeID = 58;
pub const SymEngine_TypeID_SYMENGINE_ASECH: SymEngine_TypeID = 59;
pub const SymEngine_TypeID_SYMENGINE_LAMBERTW: SymEngine_TypeID = 60;
pub const SymEngine_TypeID_SYMENGINE_ZETA: SymEngine_TypeID = 61;
pub const SymEngine_TypeID_SYMENGINE_DIRICHLET_ETA: SymEngine_TypeID = 62;
pub const SymEngine_TypeID_SYMENGINE_KRONECKERDELTA: SymEngine_TypeID = 63;
pub const SymEngine_TypeID_SYMENGINE_LEVICIVITA: SymEngine_TypeID = 64;
pub const SymEngine_TypeID_SYMENGINE_ERF: SymEngine_TypeID = 65;
pub const SymEngine_TypeID_SYMENGINE_ERFC: SymEngine_TypeID = 66;
pub const SymEngine_TypeID_SYMENGINE_GAMMA: SymEngine_TypeID = 67;
pub const SymEngine_TypeID_SYMENGINE_POLYGAMMA: SymEngine_TypeID = 68;
pub const SymEngine_TypeID_SYMENGINE_LOWERGAMMA: SymEngine_TypeID = 69;
pub const SymEngine_TypeID_SYMENGINE_UPPERGAMMA: SymEngine_TypeID = 70;
pub const SymEngine_TypeID_SYMENGINE_LOGGAMMA: SymEngine_TypeID = 71;
pub const SymEngine_TypeID_SYMENGINE_BETA: SymEngine_TypeID = 72;
pub const SymEngine_TypeID_SYMENGINE_FUNCTIONSYMBOL: SymEngine_TypeID = 73;
pub const SymEngine_TypeID_SYMENGINE_FUNCTIONWRAPPER: SymEngine_TypeID = 74;
pub const SymEngine_TypeID_SYMENGINE_DERIVATIVE: SymEngine_TypeID = 75;
pub const SymEngine_TypeID_SYMENGINE_SUBS: SymEngine_TypeID = 76;
pub const SymEngine_TypeID_SYMENGINE_ABS: SymEngine_TypeID = 77;
pub const SymEngine_TypeID_SYMENGINE_MAX: SymEngine_TypeID = 78;
pub const SymEngine_TypeID_SYMENGINE_MIN: SymEngine_TypeID = 79;
pub const SymEngine_TypeID_SYMENGINE_EMPTYSET: SymEngine_TypeID = 80;
pub const SymEngine_TypeID_SYMENGINE_FINITESET: SymEngine_TypeID = 81;
pub const SymEngine_TypeID_SYMENGINE_INTERVAL: SymEngine_TypeID = 82;
pub const SymEngine_TypeID_SYMENGINE_CONDITIONSET: SymEngine_TypeID = 83;
pub const SymEngine_TypeID_SYMENGINE_UNION: SymEngine_TypeID = 84;
pub const SymEngine_TypeID_SYMENGINE_COMPLEMENT: SymEngine_TypeID = 85;
pub const SymEngine_TypeID_SYMENGINE_IMAGESET: SymEngine_TypeID = 86;
pub const SymEngine_TypeID_SYMENGINE_PIECEWISE: SymEngine_TypeID = 87;
pub const SymEngine_TypeID_SYMENGINE_UNIVERSALSET: SymEngine_TypeID = 88;
pub const SymEngine_TypeID_SYMENGINE_CONTAINS: SymEngine_TypeID = 89;
pub const SymEngine_TypeID_SYMENGINE_BOOLEAN_ATOM: SymEngine_TypeID = 90;
pub const SymEngine_TypeID_SYMENGINE_NOT: SymEngine_TypeID = 91;
pub const SymEngine_TypeID_SYMENGINE_AND: SymEngine_TypeID = 92;
pub const SymEngine_TypeID_SYMENGINE_OR: SymEngine_TypeID = 93;
pub const SymEngine_TypeID_SYMENGINE_XOR: SymEngine_TypeID = 94;
pub const SymEngine_TypeID_SYMENGINE_EQUALITY: SymEngine_TypeID = 95;
pub const SymEngine_TypeID_SYMENGINE_UNEQUALITY: SymEngine_TypeID = 96;
pub const SymEngine_TypeID_SYMENGINE_LESSTHAN: SymEngine_TypeID = 97;
pub const SymEngine_TypeID_SYMENGINE_STRICTLESSTHAN: SymEngine_TypeID = 98;
pub const SymEngine_TypeID_SYMENGINE_TRUNCATE: SymEngine_TypeID = 99;
pub const SymEngine_TypeID_SYMENGINE_UNEVALUATED_EXPR: SymEngine_TypeID = 100;
pub const SymEngine_TypeID_TypeID_Count: SymEngine_TypeID = 101;
pub type SymEngine_TypeID = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SymEngine_EvalRealDoubleVisitorFinal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SymEngine_Visitor {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SymEngine_Basic__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SymEngine_Basic {
    pub vtable_: *const SymEngine_Basic__bindgen_vtable,
    pub _base: SymEngine_EnableRCPFromThis,
    pub hash_: std_atomic<SymEngine_hash_t>,
    pub type_code_: SymEngine_TypeID,
}
#[test]
fn bindgen_test_layout_SymEngine_Basic() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_Basic>(),
        32usize,
        concat!("Size of: ", stringify!(SymEngine_Basic))
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_Basic>(),
        8usize,
        concat!("Alignment of ", stringify!(SymEngine_Basic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SymEngine_Basic>())).hash_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SymEngine_Basic),
            "::",
            stringify!(hash_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SymEngine_Basic>())).type_code_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SymEngine_Basic),
            "::",
            stringify!(type_code_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic4hashEv"]
    pub fn SymEngine_Basic_hash(this: *const SymEngine_Basic) -> SymEngine_hash_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic7__neq__ERKS0_"]
    pub fn SymEngine_Basic___neq__(this: *const SymEngine_Basic, o: *const SymEngine_Basic)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic7__cmp__ERKS0_"]
    pub fn SymEngine_Basic___cmp__(
        this: *const SymEngine_Basic,
        o: *const SymEngine_Basic,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic7__str__B5cxx11Ev"]
    pub fn SymEngine_Basic___str__(this: *const SymEngine_Basic) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic4subsERKSt3mapINS_3RCPIKS0_EES4_NS_15RCPBasicKeyLessESaISt4pairIKS4_S4_EEE"]
    pub fn SymEngine_Basic_subs(
        this: *const SymEngine_Basic,
        subs_dict: *const SymEngine_map_basic_basic,
    ) -> SymEngine_RCP<SymEngine_Basic>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic8xreplaceERKSt3mapINS_3RCPIKS0_EES4_NS_15RCPBasicKeyLessESaISt4pairIKS4_S4_EEE"]
    pub fn SymEngine_Basic_xreplace(
        this: *const SymEngine_Basic,
        subs_dict: *const SymEngine_map_basic_basic,
    ) -> SymEngine_RCP<SymEngine_Basic>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine5Basic4diffERKNS_3RCPIKNS_6SymbolEEEb"]
    pub fn SymEngine_Basic_diff(
        this: *const SymEngine_Basic,
        x: *const SymEngine_RCP<SymEngine_Symbol>,
        cache: bool,
    ) -> SymEngine_RCP<SymEngine_Basic>;
}
impl SymEngine_Basic {
    #[inline]
    pub unsafe fn hash(&self) -> SymEngine_hash_t {
        SymEngine_Basic_hash(self)
    }
    #[inline]
    pub unsafe fn __neq__(&self, o: *const SymEngine_Basic) -> bool {
        SymEngine_Basic___neq__(self, o)
    }
    #[inline]
    pub unsafe fn __cmp__(&self, o: *const SymEngine_Basic) -> ::std::os::raw::c_int {
        SymEngine_Basic___cmp__(self, o)
    }
    #[inline]
    pub unsafe fn __str__(&self) -> std_string {
        SymEngine_Basic___str__(self)
    }
    #[inline]
    pub unsafe fn subs(
        &self,
        subs_dict: *const SymEngine_map_basic_basic,
    ) -> SymEngine_RCP<SymEngine_Basic> {
        SymEngine_Basic_subs(self, subs_dict)
    }
    #[inline]
    pub unsafe fn xreplace(
        &self,
        subs_dict: *const SymEngine_map_basic_basic,
    ) -> SymEngine_RCP<SymEngine_Basic> {
        SymEngine_Basic_xreplace(self, subs_dict)
    }
    #[inline]
    pub unsafe fn diff(
        &self,
        x: *const SymEngine_RCP<SymEngine_Symbol>,
        cache: bool,
    ) -> SymEngine_RCP<SymEngine_Basic> {
        SymEngine_Basic_diff(self, x, cache)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SymEngine_RCPBasicKeyLess {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SymEngine_RCPBasicKeyLess() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCPBasicKeyLess>(),
        1usize,
        concat!("Size of: ", stringify!(SymEngine_RCPBasicKeyLess))
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCPBasicKeyLess>(),
        1usize,
        concat!("Alignment of ", stringify!(SymEngine_RCPBasicKeyLess))
    );
}
#[repr(C)]
pub struct SymEngine_Symbol {
    pub _base: SymEngine_Basic,
    pub name_: std_string,
}
extern "C" {
    #[link_name = "\u{1}_ZN9SymEngine6Symbol12type_code_idE"]
    pub static SymEngine_Symbol_type_code_id: SymEngine_TypeID;
}
#[test]
fn bindgen_test_layout_SymEngine_Symbol() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_Symbol>(),
        64usize,
        concat!("Size of: ", stringify!(SymEngine_Symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_Symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(SymEngine_Symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SymEngine_Symbol>())).name_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SymEngine_Symbol),
            "::",
            stringify!(name_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol8as_dummyEv"]
    pub fn SymEngine_Symbol_as_dummy(
        this: *const SymEngine_Symbol,
    ) -> SymEngine_RCP<SymEngine_Symbol>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SymEngine6SymbolC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn SymEngine_Symbol_Symbol(this: *mut SymEngine_Symbol, name: *const std_string);
}
impl SymEngine_Symbol {
    #[inline]
    pub unsafe fn as_dummy(&self) -> SymEngine_RCP<SymEngine_Symbol> {
        SymEngine_Symbol_as_dummy(self)
    }
    #[inline]
    pub unsafe fn new(name: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        SymEngine_Symbol_Symbol(__bindgen_tmp.as_mut_ptr(), name);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol6acceptERNS_7VisitorE"]
    pub fn SymEngine_Symbol_accept(this: *mut ::std::os::raw::c_void, v: *mut SymEngine_Visitor);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol6acceptERNS_26EvalRealDoubleVisitorFinalE"]
    pub fn SymEngine_Symbol_accept1(
        this: *mut ::std::os::raw::c_void,
        v: *mut SymEngine_EvalRealDoubleVisitorFinal,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol8__hash__Ev"]
    pub fn SymEngine_Symbol___hash__(this: *mut ::std::os::raw::c_void) -> SymEngine_hash_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol6__eq__ERKNS_5BasicE"]
    pub fn SymEngine_Symbol___eq__(
        this: *mut ::std::os::raw::c_void,
        o: *const SymEngine_Basic,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SymEngine6Symbol7compareERKNS_5BasicE"]
    pub fn SymEngine_Symbol_compare(
        this: *mut ::std::os::raw::c_void,
        o: *const SymEngine_Basic,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct SymEngine_Expression__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SymEngine_Expression {
    pub vtable_: *const SymEngine_Expression__bindgen_vtable,
    pub m_basic: SymEngine_RCP<SymEngine_Basic>,
}
#[test]
fn bindgen_test_layout_SymEngine_Expression() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_Expression>(),
        16usize,
        concat!("Size of: ", stringify!(SymEngine_Expression))
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_Expression>(),
        8usize,
        concat!("Alignment of ", stringify!(SymEngine_Expression))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SymEngine_Expression>())).m_basic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SymEngine_Expression),
            "::",
            stringify!(m_basic)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SymEngine10ExpressionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn SymEngine_Expression_Expression(this: *mut SymEngine_Expression, s: *const std_string);
}
impl SymEngine_Expression {
    #[inline]
    pub unsafe fn new(s: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        SymEngine_Expression_Expression(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_SymEngine_RCP_open1_SymEngine_Basic_close1_std_allocator_open1_SymEngine_RCP_open2_SymEngine_Basic_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SymEngine_RCP_open1_SymEngine_Basic_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_map_open0_SymEngine_RCP_open1_SymEngine_Basic_close1_SymEngine_RCP_open1_SymEngine_Basic_close1_SymEngine_RCPBasicKeyLess_std_allocator_open1_std_pair_open2_SymEngine_RCP_open3_SymEngine_Basic_close3_SymEngine_RCP_open3_SymEngine_Basic_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_map>(),
        48usize,
        concat!("Size of template specialization: ", stringify!(std_map))
    );
    assert_eq!(
        ::std::mem::align_of::<std_map>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_map)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_pair_open1_SymEngine_RCP_open2_SymEngine_Basic_close2_SymEngine_RCP_open2_SymEngine_Basic_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_SymEngine_RCP_open1_SymEngine_Basic_close1_SymEngine_RCP_open1_SymEngine_Basic_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            std_pair<SymEngine_RCP<SymEngine_Basic>, SymEngine_RCP<SymEngine_Basic>>,
        >(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<SymEngine_RCP<SymEngine_Basic>, SymEngine_RCP<SymEngine_Basic>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            std_pair<SymEngine_RCP<SymEngine_Basic>, SymEngine_RCP<SymEngine_Basic>>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<SymEngine_RCP<SymEngine_Basic>, SymEngine_RCP<SymEngine_Basic>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_EnableRCPFromThis_open0_SymEngine_Basic_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_EnableRCPFromThis>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_EnableRCPFromThis)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_EnableRCPFromThis>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_EnableRCPFromThis)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_SymEngine_hash_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<SymEngine_hash_t>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<SymEngine_hash_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<SymEngine_hash_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<SymEngine_hash_t>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Symbol_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Symbol>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Symbol>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Symbol>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Symbol>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Symbol_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Symbol>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Symbol>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Symbol>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Symbol>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SymEngine_RCP_open0_SymEngine_Basic_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SymEngine_RCP<SymEngine_Basic>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SymEngine_RCP<SymEngine_Basic>)
        )
    );
}
